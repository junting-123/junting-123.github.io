<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>掺铒光纤放大器原理及测试</title>
      <link href="/2024/08/23/%E6%8E%BA%E9%93%92%E5%85%89%E7%BA%A4%E6%94%BE%E5%A4%A7%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/08/23/%E6%8E%BA%E9%93%92%E5%85%89%E7%BA%A4%E6%94%BE%E5%A4%A7%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;掺铒光纤放大器(EDFA)在现代光通信中具有重要的应用价值，通过光放大技术有效解决了光纤传输中衰减的问题，使其成为提升通信系统性能和降低成本的关键技术之一。<br>&emsp;&emsp;在设计和研发光纤通信EDFA的过程中，一般分为三个部分：光学部分、硬件部分以及软件部分。根据此前光通信行业工作经验，主要涉及光学部分的开发测试，现相关知识整理如下。</p><span id="more"></span><h2 id="光学基础知识"><a href="#光学基础知识" class="headerlink" title="光学基础知识"></a>光学基础知识</h2><h3 id="几何光学"><a href="#几何光学" class="headerlink" title="几何光学"></a>几何光学</h3><p>首先对校园基本的光学基础知识做一个简单回顾。<br>几何光学实质主要研究光的传播路径，忽略光的波动性质。其中光路图是几何光学的重要工具，通过描绘光线的路径，可以帮助分析光的传播、反射、折射以及成像过程。<br>如下是涉及到基本几何光学知识做个汇总记录：</p><ul><li><p>光的直线传播<br>光在均匀介质中总是沿直线传播，这称为光的直线传播定律。</p></li><li><p>反射定律<br>当光线射到两种介质的界面上（如空气和镜子），一部分光会反射回来。反射定律包括以下两个方面：<br>1、反射角等于入射角：反射光线和入射光线相对于法线（垂直于界面的线）成相等的角度。<br>2、反射光线、入射光线和法线处在同一平面。</p></li><li><p>折射定律（斯涅尔定律）<br>当光线进入另一种介质时，传播速度发生变化，导致光线偏折，进入介质后的传播方向改变。这种现象称为折射。<br>1、折射角与入射角的正弦值之比等于两种介质的折射率之比。<br>n1sin&theta;<sub>i</sub>&#x3D;n2sin&theta;<sub>r</sub><br>应用：透镜、棱镜、光纤等光学元件的工作原理都基于折射定律。</p></li><li><p>透镜成像<br>凸透镜（会聚透镜）：使平行光线汇聚在焦点上。<br>凹透镜（发散透镜）：使平行光线发散，看起来像是从虚拟焦点发出的。<br>透镜的公式如下：<br><img src="/images/12.png"><br>其中f是透镜的焦距，d<sub>0</sub>是物距（物体到透镜的距离），d<sub>i</sub>是像距（像到透镜的距离）。<br>放大倍率公式如下：<br><img src="/images/13.png"><br>M是放大率。负号表示像的方向与物体相反。</p></li><li><p>全反射<br>当光从高折射率介质进入低折射率介质时，如果入射角大于某个临界角，光线将完全反射回原介质，称为全反射。<br>临界角公式：<br><img src="/images/14.png"><br>应用：光纤通信、全反射。</p></li></ul><h3 id="物理光学"><a href="#物理光学" class="headerlink" title="物理光学"></a>物理光学</h3><p>众所周之，光具有波粒二象性，它描述了微观粒子（如光子、电子等）既表现出波动性，也表现出粒子性的特性。这个现象打破了经典物理中“波”和“粒子”是两种互不相关的现象的传统观念。<br>在物理光学中，我们将光视为电磁波，涉及波动理论和电磁理论。主要研究光的波动性、干涉、衍射、偏振等现象，特别是那些无法通过几何光学简单光线模型来解释的现象。</p><ul><li>光的波动性</li></ul><p>1、波动理论：光是一种电磁波，由电场和磁场的相互作用形成。光波可以表现出波的各种特性，如干涉、衍射和偏振。<br>2、常用参数：<br>波长（λ）：光波在空间中传播时相邻两个波峰或波谷之间的距离，决定了光的颜色或频率。<br>频率（f）：每秒钟光波振动的次数，单位为赫兹（Hz）。<br>振幅（A）：波的最大值，决定了光的强度。</p><ul><li>干涉</li></ul><p>要学习干涉与衍射，首先明白两个概念：<br>惠更斯原理：每个波阵面的每一点都可以看作是新的子波的波源，子波相加形成新的波阵面。这一原理用于解释光的衍射和反射。<br>相干光：具有恒定相位差的光波。相干光的波前相位稳定，容易产生干涉现象。</p><p>两束或多束相干光波在空间中相遇时，它们的波动会相加或相消，形成具有明暗交替的干涉图样。如下是经典的双缝干涉实验图，也是证明波粒二象性的实验：  </p><p><img src="/images/15.png"><br>此实验验证了波粒二象性：<br>1、波动性：当大量光子或电子同时通过双缝时，干涉条纹表明它们像波一样传播，相互干涉。<br>2、粒子性：当实验一个一个光子或电子进行时，每个粒子都在屏幕上打出一个离散的点，表现出粒子的特性。</p><ul><li>衍射<br>衍射是光波遇到障碍物或狭缝时绕过物体传播的现象，不再沿直线传播，而会向障碍物后方弯曲。（通常在狭缝或孔径较小）。</li></ul><p>1、单缝衍射：光通过狭缝后会产生一系列明暗相间的衍射条纹，中心条纹最亮，离中心越远条纹越暗。<br>2、多缝衍射（光栅）：光通过多条狭缝后，衍射条纹更加密集且明显，用于光谱分析。</p><p>应用：光栅光谱仪、X射线衍射、电子显微镜等，拍照时的光斑（相机镜头中的光圈和镜头光学设计导致衍射），超市的扫描条形码（细纹结构使得激光束发生衍射）</p><ul><li>偏振<br>偏振是指光波的振动方向，未偏振光的电场在所有方向上均匀分布，而偏振光的电场只在某一特定方向振动。</li></ul><p>1、线偏振光：光的电场矢量仅在一个平面内振动。<br>2、圆偏振光：光的电场矢量在垂直方向上的两个分量振幅相等，相位差为90°，呈现出圆形旋转。<br>3、椭圆偏振光：光的电场矢量在垂直方向上的两个分量振幅不同，相位差不为90°，呈现出椭圆形旋转。</p><p>应用：液晶显示器（LCD）、偏振太阳镜、显微镜偏振光分析等。</p><ul><li>光的色散</li></ul><p>色散是光在不同波长下折射率不同的现象，使得不同颜色的光分开。最经典的例子是白光通过棱镜分解成彩虹色的光谱。<br><img src="/images/16.png"></p><p>应用：棱镜光谱仪、光纤色散管理等。</p><h2 id="掺铒光纤放大器原理与设计流程"><a href="#掺铒光纤放大器原理与设计流程" class="headerlink" title="掺铒光纤放大器原理与设计流程"></a>掺铒光纤放大器原理与设计流程</h2><h3 id="EDFA的原理"><a href="#EDFA的原理" class="headerlink" title="EDFA的原理"></a>EDFA的原理</h3><p>掺铒光纤放大器(Er3+ Droped Fiber Amplifier, EDFA)的出现是光纤通信发展史上一个重要里程碑。1986年英国南安普敦大学制作出了最初的掺铒光纤放大器。在此之前，由于不能直接放大光信号，所有的光纤通信系统都只能采用光-电-光中继方式。光纤放大器可直接放大光信号，这就可使光-电-光中继变为全光中继。这是一次极为重要的飞跃，把光通信推向了一个新的阶段。</p><p>EDFA光放大的实质使光纤中掺杂饵离子，通过泵浦信号提供能量，使处于基态能带的饵离子跃迁到激发态能带（泵浦能带），但由于激发态是不稳定的，饵离子很快回到亚稳态能带，实现粒子数的反转。当输入光的光子能量等于从亚稳态到基态的能量差的时候，这时处于亚稳态的饵离子跃迁到基态，从而产生受激辐射，使得输出的光信号得到放大。 </p><p><img src="/images/18.png"></p><p>掺铒光纤放大器主要用于提升光信号的传输距离和质量。它工作于1550nm波长的，以掺铒光纤作为增益介质，以980nm或者1480nm附近波长的激光器作为泵浦光源的一种放大器。<br>由于其工作在1550 nm波段（光纤的低损耗窗口），具有低噪声、高增益等优点。EDFA在以下应用中发挥着关键作用：</p><p>1、长距离光纤通信<br>EDFA在不进行光-电-光（O-E-O）转换的情况下，直接放大光信号的强度，补偿光信号在长距离传输中的损耗，从而延长光纤通信的有效传输距离。</p><p>2、波分复用（WDM）系统<br>波分复用系统通过在一根光纤中传输多个不同波长的光信号大幅提高通信容量，但随着信号传播，所有波长信号发生衰减，EDFA对多种波长的信号具有宽带放大效果。</p><p>3、光纤激光器<br>基于光纤技术的激光器，广泛应用于材料加工、医疗与激光雷达，EDFA可以用于光纤激光器中作为增益介质，放大激光的输出功率。</p><p>EDFA一般由5个基本部分组成 ：  </p><ul><li><p>泵浦光源（pump-LD）<br>提供足够强的泵浦功率，提供增益，一般使用98nm、1550nm的泵浦激光器，来激发光纤中饵离子，从而实现光信号放大</p></li><li><p>掺铒光纤（EDA）  </p></li><li><p>光无源器件<br>耦合器:将信号光和泵浦光耦合在一起，一般采用波分复用器。<br>光隔离器：隔离反馈光信号，提高稳定性。<br>光滤波器：滤除放大过程中产生的噪声。<br>光纤连接器</p></li><li><p>控制单元<br>对光纤放大器的工作实时控制。</p></li><li><p>监控接口<br>提供工作状态信息。</p></li></ul><p>实现传输过程如图所示，泵浦光与被放大信号光一起通过光耦合器或波分复用耦合器注入掺铒光纤，实现光放大。在传输过程中的每个环节连接上控制单元，方便精确调控每部分的增益参数，实时监控各环节的性能指标，确保放大器稳定运行和实现自动化管理。</p><p><img src="/images/17.png"></p><h3 id="EDFA设计流程"><a href="#EDFA设计流程" class="headerlink" title="EDFA设计流程"></a>EDFA设计流程</h3><p>工程中EDFA光学设计整体流程如下。</p><p>1、首先根据spec需求，对光路进行设计，通过光学模拟软件如Ampilifier4.0,对设计结果进行模拟仿真。重点是确定光路的结构、Pump的大小以及Er纤的长度。</p><p>2、在模拟仿真的过程中，需要对增益平坦滤波器(GFF)进行设计，每款EDFA所用到的GFF都不一样，需要单独进行设计。</p><p>3、根据仿真结果进行桌面实验，来验证仿真结果是否正确，并对仿真结果进行修改和调整，最终确定方案。</p><p>4、盒盘，对每个光纤熔接点需要进行监控。</p><p>5、盘盒后测试。</p><p>其中最重要的设计环节就是定标，定标是指通过调节和校准放大器的参数，使其输出性能符合特定标准或要求的过程。工程人员通常需要对如下参数一一定标，确保放大器在工作时能够达到预期的性能水平：</p><ul><li><p>Pump定标：Pump电流值与Pump输出光功率的对应关系，生成DAC与输出光功率的对应表。</p></li><li><p>VOA定标：VOA电流值与VOA衰减值的对应关系，生成DAC与衰减值的对应表。</p></li><li><p>所有PD定标：PD探测到的ADC值和进光功率的对应关系，生成ADC与进光功率的对应表。包括入光PD、出光PD、VOAin PD、VOAout PD，若有中间级，还需要MSAin PD和MSAout PD。</p></li><li><p>Gain定标：在Gain的变化范围内，取一定间隔的Gain，在此Gain下，输入光功率，输出光功率，Pump光功率及ASE功率的对应关系，生成Gain表。</p></li></ul><h3 id="EDFA增益定标"><a href="#EDFA增益定标" class="headerlink" title="EDFA增益定标"></a>EDFA增益定标</h3><p>市场对EDFA性能评判性能指标主要体现在增益、输出功率和噪声。其中最重要指标就是增益G，它是用来描述光放大器对信号的放大能力，表示为输出功率与输入功率的比值。如下为它的数学定义，一使用dB表示：<br><img src="/images/19.png"></p><p>一般情况下，增益与泵浦功率有直接的关系，与掺铒光纤的长度也有关系，所以工程人员需要通过实验找到他们最佳的值。</p><h3 id="GFF增益平坦滤波"><a href="#GFF增益平坦滤波" class="headerlink" title="GFF增益平坦滤波"></a>GFF增益平坦滤波</h3><h2 id="软件控制部分"><a href="#软件控制部分" class="headerlink" title="软件控制部分"></a>软件控制部分</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集群智能管理与监控</title>
      <link href="/2024/08/19/%E9%9B%86%E7%BE%A4%E6%99%BA%E8%83%BD%E7%AE%A1%E7%90%86%E4%B8%8E%E7%9B%91%E6%8E%A7/"/>
      <url>/2024/08/19/%E9%9B%86%E7%BE%A4%E6%99%BA%E8%83%BD%E7%AE%A1%E7%90%86%E4%B8%8E%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;集群技术是一种通过将多台计算机（节点）联合在一起，以提供单一服务或实现高性能、高可用性和可扩展性的技术。其应用场景非常广泛，可广泛应用于科学计算、大数据处理、网络服务等领域。<br>&emsp;&emsp;集群管理在现代 IT 基础设施中起着至关重要的作用，而其管理涉及到集群的部署、监控、维护和优化。以下是根据研究生阶段在中物院短暂的集群运维经验，相关知识整理记录如下。</p><span id="more"></span><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux是一个开源、自由传播、支持多用户同时操作、多任务、支持多CPU、多线程的操作系统。集群的管理通常需要使用到 Linux 命令，包括从节点的配置、部署到日常的维护、监控和调试。所以具备一定的Linux操作系统知识非常有必要。</p><h3 id="计算机硬件介绍"><a href="#计算机硬件介绍" class="headerlink" title="计算机硬件介绍"></a>计算机硬件介绍</h3><ul><li>CPU：中央处理器。进行逻辑运算和调度其他设备工作，服务器cpu在2-4颗，单核cpu是4核，总量在16-256G左右</li><li>内存条:存储临时数据。内存解决的是cpu和磁盘之间的速度不平等，cpu处理过快，磁盘速度太慢，这中间就需要搭起传输桥梁。默认下，cpu是从内存中读写数据，内存从磁盘中获取数据。</li><li>显卡：处理计算机图形相关工作。</li><li>主板：集成电路板，将所有元件连接在一起。BIOS则为主板设置系统。</li><li>硬盘：用于存储计算机数据。</li></ul><p>输入设备为键盘鼠标，能够发送设备；输出设备为显示屏；主机部分则为机箱，保护零件。</p><h3 id="Linux核心命令"><a href="#Linux核心命令" class="headerlink" title="Linux核心命令"></a>Linux核心命令</h3><p>Linux目录结构：</p><ul><li>&#x2F;     #根目录</li><li>&#x2F;dev  #存放抽象硬件</li><li>&#x2F;lib  #存放系统库文件</li><li>&#x2F;sbin  #存放特权级二级制文件</li><li>&#x2F;var   #存放经常变化的文件</li><li>&#x2F;home  #普通用户目录</li><li>&#x2F;etc   #存放配置文件目录</li><li>&#x2F;boot  #存放内核与启动文件</li><li>&#x2F;bin   #存放二进制文件（可执行命令）</li><li>&#x2F;usr   #存放安装程序（软件默认目录）</li><li>&#x2F;mnt   #文件挂在目录（u盘、光驱）</li><li>&#x2F;root  #特权用户目录</li><li>&#x2F;opt   #大型软件存放目录（非强制）<br>其中文件有三种权限：r为可读权限；w为可写权限；x为可执行权限</li></ul><p>Linux核心命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>     <span class="comment">#跳转目录</span></span><br><span class="line"><span class="built_in">ls</span>     <span class="comment">#列出文件夹内容</span></span><br><span class="line"><span class="built_in">pwd</span>    <span class="comment">#打印工作目录</span></span><br><span class="line">su     <span class="comment">#命令用户切换</span></span><br><span class="line"><span class="built_in">logout</span> <span class="comment">#退出当前的用户</span></span><br><span class="line"><span class="built_in">mkdir</span>  <span class="comment">#创建文件夹</span></span><br><span class="line"><span class="built_in">touch</span>  <span class="comment">#创建普通文件</span></span><br><span class="line"><span class="built_in">cp</span>     <span class="comment">#./junting1/JUNTING.txt ;复制放入其他文件夹并改名</span></span><br><span class="line"><span class="built_in">cat</span>    <span class="comment">#显示文件内容</span></span><br><span class="line"><span class="built_in">echo</span>   <span class="comment">#输出文本到终端</span></span><br><span class="line"><span class="built_in">rm</span>     <span class="comment">#删除；rm -f（强制删除不提示);*删除文件夹必须加上-r</span></span><br></pre></td></tr></table></figure><p>如果想要查看帮助，输入q 退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#man + 命令  #查看帮助，输入q 退出</span></span><br><span class="line"><span class="comment">#命令  --help</span></span><br><span class="line"><span class="comment">#help 命令</span></span><br></pre></td></tr></table></figure><h3 id="Linux文本处理命令"><a href="#Linux文本处理命令" class="headerlink" title="Linux文本处理命令"></a>Linux文本处理命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep  <span class="comment">#搜索文本中的模式；grep -i &quot;pattern&quot; file.txt(在 file.txt 文件中搜索包含 pattern 的所有行)</span></span><br><span class="line">awk   <span class="comment">#处理文本数据；awk &#x27;$1 == &quot;value&quot;&#x27; file.txt(打印 file.txt 中第一字段等于 value 的行)</span></span><br><span class="line">sed   <span class="comment">#流编辑器，用于文本替换和编辑。</span></span><br><span class="line"><span class="built_in">cut</span>   <span class="comment">#从文本中提取字段；cut -c 4-6 alex.txt (每行从第4个切割刀第6个字符)</span></span><br><span class="line"><span class="built_in">sort</span>  <span class="comment">#对文本进行排序；sort -n sort.txt(针对数字从小到大排序，加个r从大到小)</span></span><br><span class="line"><span class="built_in">uniq</span>  <span class="comment">#删除重复行。</span></span><br></pre></td></tr></table></figure><h3 id="Linux系统和进程管理命令"><a href="#Linux系统和进程管理命令" class="headerlink" title="Linux系统和进程管理命令"></a>Linux系统和进程管理命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps      <span class="comment">#显示当前进程。</span></span><br><span class="line">top     <span class="comment">#实时显示系统资源使用情况（Git Bash 不支持）。</span></span><br><span class="line"><span class="built_in">kill</span>    <span class="comment">#终止进程。</span></span><br><span class="line"><span class="built_in">uptime</span>  <span class="comment">#显示系统运行时间（Git Bash 不支持）。</span></span><br><span class="line"><span class="built_in">df</span>      <span class="comment">#显示文件系统磁盘空间使用情况。</span></span><br><span class="line"><span class="built_in">du</span>      <span class="comment">#显示目录或文件的磁盘使用量。</span></span><br></pre></td></tr></table></figure><h3 id="Linux网络命令"><a href="#Linux网络命令" class="headerlink" title="Linux网络命令"></a>Linux网络命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ping    <span class="comment">#检查网络连通性。</span></span><br><span class="line">curl    <span class="comment">#下载或上传数据。</span></span><br><span class="line">wget    <span class="comment">#下载文件。</span></span><br><span class="line">ssh     <span class="comment">#通过 SSH 连接到远程主机。</span></span><br></pre></td></tr></table></figure><h3 id="vim编译与shell脚本"><a href="#vim编译与shell脚本" class="headerlink" title="vim编译与shell脚本"></a>vim编译与shell脚本</h3><p>Vim 是一种高度可配置的文本编辑器，常用于编程和系统管理。它基于 vi 编辑器，提供了更多的功能和灵活性。他具有三种基本模式：</p><ul><li>普通模式<br>这是 Vim 启动时的默认模式，用于导航和执行命令。可以通过按 Esc 键进入普通模式。</li><li>插入模式<br>在插入模式中，你可以插入和编辑文本。通过按 i、I、a、A、o、O 等键进入插入模式，按 Esc 返回普通模式。</li><li>命令模式<br>在命令模式中，你可以执行各种命令，如保存文件、退出 Vim 等。通过按 : 进入命令模式，输入命令后按 Enter 执行。</li></ul><p>vim启动与保存退出的相关命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim filename  <span class="comment">#启动</span></span><br><span class="line">：wq          <span class="comment">#保存退出</span></span><br><span class="line">：w           <span class="comment">#只保存</span></span><br><span class="line">：q           <span class="comment">#只退出</span></span><br></pre></td></tr></table></figure><p>Shell 脚本称为bash shell 程序，本质就是将一系列 Linux 命令和控制结构组织在一起，通过脚本文件来实现自动化任务和批量处理。Shell 脚本可以包含各种 Shell 命令、条件语句、循环、函数等，用于执行复杂的操作和实现自动化功能。通常显示为 *.sh 文件。如下为shell脚本经典实例（可在window中git bash测试）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 获取用户输入</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your name: &quot;</span> name</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your age: &quot;</span> age</span><br><span class="line"><span class="comment"># 输出信息</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>! You are <span class="variable">$age</span> years old.&quot;</span></span><br></pre></td></tr></table></figure><p>其中#!&#x2F;bin&#x2F;bash是脚本文件的解释器，一种特殊注释为Shebang行（能够指定解释器，确保脚本在不同环境中的一致性，并简化脚本的执行）。它告诉操作系统在执行脚本时应该使用哪个程序来解释脚本中的命令。但他不是强制性的，它只是一个最佳实践。<br>运行shell脚本有两种方式</p><ul><li>直接.&#x2F;*.sh</li><li>sh *.sh</li></ul><h2 id="集群整机压测"><a href="#集群整机压测" class="headerlink" title="集群整机压测"></a>集群整机压测</h2><h3 id="Slurm调度系统"><a href="#Slurm调度系统" class="headerlink" title="Slurm调度系统"></a>Slurm调度系统</h3><p>Slurm（Simple Linux Utility for Resource Management）是一个开源的、高效的集群管理调度系统，用于管理和调度大型计算集群中的计算资源。Slurm具有高可用性和可扩展性，易于使用，提供了丰富的命令行界面和API，可以为科学研究和工程计算等领域提供高效的支持。<br>*注：参与运维集群时，已部署好Slurm调度系统。</p><h3 id="sinfo"><a href="#sinfo" class="headerlink" title="sinfo"></a>sinfo</h3><p>集群系统中的单个计算机通常称为节点，通常通过局域网连接。sinfo是 Slurm 作业调度系统中用于查询集群状态的命令。期间我主要用它做整机测试，检测服务器的连接状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinfo</span><br></pre></td></tr></table></figure><p>sinfo通常包括以下字段</p><ul><li>PARTITION：分区名称。分区是 Slurm 中的一个资源池，作业被调度到特定的分区中。</li><li>NODELIST：节点列表。显示分区中包括的所有节点的名称。</li><li>STATE：节点的状态。常见的状态包括<br>idle      #空闲，没有正在运行的作业<br>drain     #节点处于维护模式，暂时不接受作业。<br>down*     #节点无法使用，故障<br>mixed     #节点部分空闲，部分已分配。<br>alloc     #节点已分配给正在运行的作业。</li></ul><p>如下是sinfo的示例输出，实时输出每个节点的运行状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PARTITION  AVAIL  TIMELIMIT  NODES  STATE  NODELIST</span><br><span class="line">debug*     up     infinite   4      idle   node[01-04]</span><br><span class="line">compute    up     infinite   6      alloc  node[05-10]</span><br></pre></td></tr></table></figure><p>我们也可以使用脚本定期检查节点是否有任何故障（如 “down” 状态）是维护集群健康的重要部分。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  sinfo | grep -i down</span><br><span class="line">  <span class="built_in">sleep</span> 60</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="跑循环计算"><a href="#跑循环计算" class="headerlink" title="跑循环计算"></a>跑循环计算</h3><p>考虑到实际使用中，集群可能出现间断计算使用，导致忽冷忽热，硬件可能在温度循环中变得不稳定，所以为了验证其整机的可靠性，我们采用每半个小时负载跑计算，停止半小时，再继续半小时计算，如此循环状态下，检测集群在高负载循环下能够稳定运行，并且不会因为过热而导致性能下降或硬件损坏。</p><ul><li><p>首先确保集群节点上已安装 stress 工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install stress</span><br></pre></td></tr></table></figure></li><li><p>设置 SSH 密钥登录<br>为了无密码登录到每个节点，可以配置 SSH 密钥对</p></li><li><p>编写计算脚本stress_test.sh：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点列表，按照实际情况替换</span></span><br><span class="line">NODES=(<span class="string">&quot;node1&quot;</span> <span class="string">&quot;node2&quot;</span> <span class="string">&quot;node3&quot;</span>)  <span class="comment"># 替换为你的集群节点名或 IP 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 负载参数</span></span><br><span class="line">CPU_LOAD=4     <span class="comment"># 每个节点上启动的 CPU 负载数</span></span><br><span class="line">MEMORY_LOAD=2G <span class="comment"># 每个节点上模拟的内存负载</span></span><br><span class="line">DURATION=3600  <span class="comment"># 负载持续时间（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程命令</span></span><br><span class="line">STRESS_CMD=<span class="string">&quot;stress --cpu <span class="variable">$&#123;CPU_LOAD&#125;</span> --vm 1 --vm-bytes <span class="variable">$&#123;MEMORY_LOAD&#125;</span> --timeout <span class="variable">$&#123;DURATION&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历节点并运行负载测试</span></span><br><span class="line"><span class="keyword">for</span> NODE <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;NODES[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Starting stress test on <span class="variable">$&#123;NODE&#125;</span>...&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 SSH 远程执行负载测试命令</span></span><br><span class="line">    ssh <span class="string">&quot;hadmin@<span class="variable">$&#123;NODE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;STRESS_CMD&#125;</span>&quot;</span> &amp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Failed to start stress test on <span class="variable">$&#123;NODE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Stress test started on <span class="variable">$&#123;NODE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有后台进程完成</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Stress testing completed on all nodes.&quot;</span></span><br></pre></td></tr></table></figure><p>这个脚本会在集群中的每个节点上启动负载测试，模拟高负载情况，以帮助评估系统的稳定性和性能。你可以根据实际需求调整脚本中的节点列表、负载参数和其他设置。</p><ul><li>运行脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stress_test.sh</span><br></pre></td></tr></table></figure></li></ul><h2 id="监控与日志管理"><a href="#监控与日志管理" class="headerlink" title="监控与日志管理"></a>监控与日志管理</h2><h3 id="IPMI"><a href="#IPMI" class="headerlink" title="IPMI"></a>IPMI</h3><p>在集群管理中，研究所使用到的服务器在179台左右，需要对大量服务器进行监控与管理，特别是初期硬件不太稳定，主要对硬件层面的管控。然而我们不可能一天24小时呆在机房，所以需要远程管理系统对其进行控制。<br>IPMI是一种用于系统管理的标准接口，可用于监控和管理计算机系统的硬件，允许管理员对服务器进行远程操控（孩子再也不用来回跑机房了~~）。<br>IPMI主要功能：</p><ul><li>远程监控<br>1、硬件健康状态：监控系统的温度、风扇速度、电压、硬件故障等；<br>3、远程管理：远程开关机：允许管理员在系统远程关闭、重启或启动服务器。<br>4、远程控制：提供对服务器的远程控制，包括远程访问 BIOS 设置和操作系统。<br>5、重置系统：可以远程重置系统，以解决系统挂起或崩溃问题。</li><li>传感器监控<br>1、温度传感器：监控 CPU、主板和其他组件的温度。<br>2、风扇速度：监控风扇速度，确保散热系统正常工作。<br>3、电压传感器：监控系统的电压水平，确保稳定性。</li><li>日志记录：<br>系统事件日志：记录硬件事件和错误，以帮助进行故障排除；</li><li>远程控制台：<br>提供对服务器的虚拟控制台访问，允许管理员在操作系统启动之前进行控制和操作。</li></ul><p>IPMI 的组成：</p><ul><li>BMC（Baseboard Management Controller）：<br>这是 IPMI 的核心组件，负责与服务器的硬件进行通信，处理传感器数据和远程管理命令。<br>通常，BMC 是集成在主板上的专用微控制器。即使操作系统崩溃，BMC 仍然可以监控和管理硬件。</li><li>IPMI 规范：<br>这是一个定义 IPMI 功能和接口的标准，规定了如何进行硬件监控和管理。</li><li>管理软件：<br>提供与 BMC 进行通信的工具和应用程序，允许管理员通过图形用户界面或命令行工具来管理系统</li></ul><p>了解完IPMI强大功能，我们对其进行安装，在 Debian&#x2F;Ubuntu 系统中,安装IPMI，帮助读取主板和其他传感器温度数据:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install ipmitool</span><br></pre></td></tr></table></figure><h3 id="远程开关机"><a href="#远程开关机" class="headerlink" title="远程开关机"></a>远程开关机</h3><p>集群使用的IPMI默认用户名admin以及密码admin，可通过ssh经过ipmi控制，实现服务器远程开关机。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipmitool -I  lanplus -H 地址 -U admin -P admin power reset <span class="comment">#开机</span></span><br><span class="line">ipmitool -I lanplus -H &lt;IPMI_IP&gt; -U &lt;USERNAME&gt; -P &lt;PASSWORD&gt; power off</span><br><span class="line"><span class="comment">#关机</span></span><br></pre></td></tr></table></figure><h3 id="温度监控"><a href="#温度监控" class="headerlink" title="温度监控"></a>温度监控</h3><p>高集中的服务器产生大量热量，所以对温度的监控十分重要。除了安装机房温度报警装置，初期还要定时监控主板温度。可以从ipmi接口获取温度信息。<br>编写shell脚本检测温度，它将使用 ipmitool 工具从每个节点获取主板温度，并记录到日志文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点列表，按照实际情况替换</span></span><br><span class="line">NODES=(<span class="string">&quot;node1&quot;</span> <span class="string">&quot;node2&quot;</span> <span class="string">&quot;node3&quot;</span>)  <span class="comment"># 替换为你的集群节点名或 IP 地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IPMI 配置信息</span></span><br><span class="line">IPMI_USER=<span class="string">&quot;admin&quot;</span>  <span class="comment"># 替换为实际的 IPMI 用户名</span></span><br><span class="line">IPMI_PASS=<span class="string">&quot;password&quot;</span>  <span class="comment"># 替换为实际的 IPMI 密码</span></span><br><span class="line">IPMI_INTERFACE=<span class="string">&quot;lanplus&quot;</span>  <span class="comment"># IPMI 接口类型（例如 lanplus）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 温度监控日志文件</span></span><br><span class="line">LOGFILE=<span class="string">&quot;/var/log/ipmi_temp.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入日志文件的函数</span></span><br><span class="line"><span class="function"><span class="title">log_temp</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> NODE=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> TEMP=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date)</span>: <span class="variable">$&#123;NODE&#125;</span> - Temperature: <span class="variable">$&#123;TEMP&#125;</span>°C&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;LOGFILE&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控每个节点的主板温度</span></span><br><span class="line"><span class="keyword">for</span> NODE <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;NODES[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Checking temperature on <span class="variable">$&#123;NODE&#125;</span>...&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 IPMI 工具获取温度信息</span></span><br><span class="line">    TEMP=$(ipmitool -I <span class="variable">$&#123;IPMI_INTERFACE&#125;</span> -H <span class="variable">$&#123;NODE&#125;</span> -U <span class="variable">$&#123;IPMI_USER&#125;</span> -P <span class="variable">$&#123;IPMI_PASS&#125;</span> sdr | grep -i <span class="string">&quot;System Temp&quot;</span> | awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | sed <span class="string">&#x27;s/°C//&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$TEMP</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Failed to get temperature from <span class="variable">$&#123;NODE&#125;</span>&quot;</span> &gt;&gt; <span class="string">&quot;<span class="variable">$&#123;LOGFILE&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        log_temp <span class="string">&quot;<span class="variable">$&#123;NODE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;TEMP&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Temperature monitoring completed.&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发</title>
      <link href="/2024/08/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2024/08/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;现如今微信受众人群越来越广泛，想尝试着搭建个微信小程序玩玩。一来想把脑中的灵感实体化，二来学习下前端方面的知识。<span id="more"></span></p><h2 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>&emsp;&emsp;微信小程序开发者工具是用于开发和调试微信小程序的官方工具，提供了丰富的功能来帮助开发者进行小程序的开发、测试和优化。进入 <a href="https://mp.weixin.qq.com/">小程序开发浏览器</a>，在工具栏里点击下载对应操作系统的开发工具。<br><img src="/images/1.png"></p><h2 id="小程序创建与初始化配置"><a href="#小程序创建与初始化配置" class="headerlink" title="小程序创建与初始化配置"></a>小程序创建与初始化配置</h2><h3 id="建立小程序"><a href="#建立小程序" class="headerlink" title="建立小程序"></a>建立小程序</h3><p>&emsp;&emsp;创建一个小程序存放的文件夹，下载安装好开发工具后，在运行页面点击加号，创建小程序，如下图。<br><img src="/images/2.png"><br>输入小程序注册相关信息，包括项目名称，存放目录，开发学习阶段可选用测试号，注意全部分类中模板请选用不使用模板，下图是我注册信息。<br><img src="/images/3.png"><br>注册完成后点击创建。看到如下画面说明注册成功。<br><img src="/images/4.png"></p><h3 id="页面初始化配置"><a href="#页面初始化配置" class="headerlink" title="页面初始化配置"></a>页面初始化配置</h3><p>&emsp;&emsp;进入资源管理器中的index.wxml,删除如下所有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.wxml--&gt;</span><br><span class="line">&lt;navigation-bar title=<span class="string">&quot;Weixin&quot;</span> back=<span class="string">&quot;&#123;&#123;false&#125;&#125;&quot;</span> color=<span class="string">&quot;black&quot;</span> background=<span class="string">&quot;#FFF&quot;</span>&gt;&lt;/navigation-bar&gt;</span><br><span class="line">&lt;scroll-view class=<span class="string">&quot;scrollarea&quot;</span> scroll-y <span class="built_in">type</span>=<span class="string">&quot;list&quot;</span>&gt;</span><br><span class="line">  &lt;view class=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">    Weixin</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br></pre></td></tr></table></figure><p>任意添加文字,点击编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi,everyone</span><br></pre></td></tr></table></figure><p>发现编译好的文案出现在顶部，官方默认顶部导航隐藏，这给我们开发可能带来限制，所以我们要将官方此功能去掉。首先进入app.json，只保留如下信息，其余全删掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pages&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;window&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;navigationBarTextStyle&quot;</span>: <span class="string">&quot;black&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;componentFramework&quot;</span>: <span class="string">&quot;glass-easel&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sitemapLocation&quot;</span>: <span class="string">&quot;sitemap.json&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lazyCodeLoading&quot;</span>: <span class="string">&quot;requiredComponents&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再进入index.json脚本中，删除:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;usingComponents&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;navigation-bar&quot;</span>: <span class="string">&quot;/components/navigation-bar/navigation-bar&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只保留一对大空格。<br>最后删除components文件夹，pages中.eslintrc.js文件。点击编译，到此整个项目就是一个空白且完整的项目。</p><h2 id="小程序开发三剑客"><a href="#小程序开发三剑客" class="headerlink" title="小程序开发三剑客"></a>小程序开发三剑客</h2><h3 id="小程序开发之wxml"><a href="#小程序开发之wxml" class="headerlink" title="小程序开发之wxml"></a>小程序开发之wxml</h3><p>&emsp;&emsp;资源管理器中每个脚本功能:</p><p><img src="/images/5.png"></p><p>其中页面最重要的三剑客<br>1、wxml(布局，相当建筑中大楼框架)<br>2、wxss(显示，相当于大楼内部装饰)<br>3、js(逻辑，相当于具备的功能)<br>其中最重要的就是逻辑功能开发，首先开始开发前，可以将里面对应内容先清空。<br>WXML（WeiXin Markup Language）是微信小程序中用于描述页面结构的标记语言，类似于 HTML。WXML 主要用于定义小程序的页面布局和内容。可以使用 &lt;view&gt;、&lt;text&gt;、&lt;image&gt; 等标签来构建页面布局。我们假定装修一栋大楼，首先布局大楼每层的框架，如下是wxml布局code：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建wxml大楼骨架--&gt;</span><br><span class="line">&lt;view class=<span class="string">&quot;dalou&quot;</span>&gt;</span><br><span class="line">    &lt;!--3楼--&gt;</span><br><span class="line">    &lt;view class=<span class="string">&quot;sanlou&quot;</span>&gt;</span><br><span class="line">        电影院|理发店</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!--2楼--&gt;</span><br><span class="line">    &lt;view class=<span class="string">&quot;erlou&quot;</span>&gt;</span><br><span class="line">        ktv|奶茶店</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!--1楼--&gt;</span><br><span class="line">    &lt;view class=<span class="string">&quot;yilou&quot;</span>&gt;</span><br><span class="line">        服装店|按摩店</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>模拟界面显示如下，说明配置成功。<br><img src="/images/6.png"></p><h3 id="小程序开发之wxss"><a href="#小程序开发之wxss" class="headerlink" title="小程序开发之wxss"></a>小程序开发之wxss</h3><p>&emsp;&emsp;WXSS（WeiXin Style Sheets）是微信小程序的样式表语言，用于定义小程序中页面和组件的样式。它类似于 CSS，但具有一些特定于微信小程序的特性。接以上我们对大楼外观做设定，这里以颜色作为例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.dalou&#123;</span><br><span class="line">    background:green;</span><br><span class="line">&#125;</span><br><span class="line">.sanlou&#123;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br><span class="line">.erlou&#123;</span><br><span class="line">    background:green;</span><br><span class="line">&#125;</span><br><span class="line">.yilou&#123;</span><br><span class="line">    background: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出界面为下面：<br><img src="/images/7.png"></p><h3 id="小程序开发之js"><a href="#小程序开发之js" class="headerlink" title="小程序开发之js"></a>小程序开发之js</h3><p>&emsp;&emsp;在微信小程序开发中，JavaScript（JS）用于编写页面和组件的逻辑代码。它负责处理用户交互、数据管理、网络请求等功能。接如上，对商店组件赋予功能，点击即释放其功能。其中先对xml里组件通过bindtap定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建wxml大楼骨架--&gt;</span><br><span class="line">&lt;view class=<span class="string">&quot;dalou&quot;</span>&gt;</span><br><span class="line">    &lt;!--3楼--&gt;</span><br><span class="line">    &lt;view class=<span class="string">&quot;sanlou&quot;</span>&gt;</span><br><span class="line">    &lt;text bindtap=<span class="string">&quot;dianyingyuan&quot;</span>&gt;电影院&lt;/text&gt;&lt;text&gt;理发店&lt;/text&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!--2楼--&gt;</span><br><span class="line">    &lt;view class=<span class="string">&quot;erlou&quot;</span>&gt;</span><br><span class="line">    &lt;text&gt;ktv&lt;/text&gt;&lt;text bindtap=<span class="string">&quot;naichadian&quot;</span>&gt;奶茶店&lt;/text&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!--1楼--&gt;</span><br><span class="line">    &lt;view class=<span class="string">&quot;yilou&quot;</span>&gt;</span><br><span class="line">    &lt;text&gt;服装店&lt;/text&gt;&lt;text&gt;按摩店&lt;/text&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>接着切换index.js对功能进行编写，如下例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">    //电影播放功能</span><br><span class="line">    <span class="function"><span class="title">dianyingyuan</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">&quot;电影院开始放电影了！&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    //奶茶店喝奶茶功能</span><br><span class="line">    <span class="function"><span class="title">naichadian</span></span>()&#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">            title:<span class="string">&#x27;我要喝甜甜的奶茶&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击按钮释放的功能如下：<br><img src="/images/9.png"><br><img src="/images/8.png"></p><h2 id="小程序开发组件"><a href="#小程序开发组件" class="headerlink" title="小程序开发组件"></a>小程序开发组件</h2><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p>&emsp;&emsp;app.json是小程序项目的配置文件，用于配置整个小程序的全局信息，比如页面路径、窗口表现、导航栏颜色等。它是微信小程序的核心文件之一，决定了小程序的页面路径和一些默认的界面配置。<br>在代码目录app.json中添加如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;pages&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;pages/test1/test1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pages/index/index&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>此操作在pages中创建一个新界面test1。</p><h3 id="view组件"><a href="#view组件" class="headerlink" title="view组件"></a>view组件</h3><p>&emsp;&emsp;<a href="https://developers.weixin.qq.com/miniprogram/dev/component/">微信小程序官方组件</a>里记载了组件的详细使用方法。以下针对常用的组件做简单的实例介绍。<br>view（布局框）组件是微信小程序中的基础容器组件，类似于 HTML 中的 div 元素。它可以作为容器，用来包裹其他组件，并且可以设置样式、响应点击等事件。并且自动占满一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;我是小俊廷&lt;/view&gt;</span><br><span class="line">&lt;view&gt;你是何瓜瓜&lt;/view&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;view&gt;xxxx&lt;&#x2F;view&gt;<br>view 组件主要用来布局整体结构。</li></ul><h3 id="text组件"><a href="#text组件" class="headerlink" title="text组件"></a>text组件</h3><p>&emsp;&emsp;text(文本框) 组件是微信小程序中的基础文本组件，用于显示文本内容。它类似于 HTML 中的 <span> 元素，通常用于展示一段文本，并支持部分基础的文本样式设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;text&gt;i love you&lt;/text&gt;</span><br><span class="line">&lt;text&gt;so <span class="keyword">do</span> i&lt;/text&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;text&gt;xxxx&lt;&#x2F;text&gt;</li></ul><p>运行后对比view组件明显观察出，它并不会占满一行。<br>我们继续对其view与text定义class参数。<br>注意：class 是一个用于指定元素的 CSS 样式类的属性。它用于为组件或元素应用特定的样式规则，以控制其外观。<br>先在wxml中布局如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=<span class="string">&quot;fu&quot;</span>&gt;</span><br><span class="line">    &lt;text class=<span class="string">&quot;zi&quot;</span>&gt;我是view里text&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>在wxss分别进行引用并赋予颜色装饰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fu&#123;</span><br><span class="line">    background: green; <span class="comment">#对fu属性赋绿色</span></span><br><span class="line">    pedding:10rpx;</span><br><span class="line">&#125;</span><br><span class="line">.zi&#123;</span><br><span class="line">    background: red;  <span class="comment">#对zi属性赋红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显观察到&lt;view&gt;与&lt;text&gt;的区别，fu为view定义属性，占满整行，为布局属性，而zi为text属性，只占自己的字符位置，为文本属性：<br><img src="/images/10.png"></p><h3 id="input组件"><a href="#input组件" class="headerlink" title="input组件"></a>input组件</h3><p>&emsp;&emsp;input 组件用于获取用户的文本输入。该组件支持多种类型的输入，例如文本、数字、密码等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input placeholder=<span class="string">&quot;我是输入框&quot;</span> maxlength=<span class="string">&quot;5&quot;</span>&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;input&gt;xxxx&lt;&#x2F;input&gt;<br>如上是输入框占位符且限制输入数量为5。</li></ul><h3 id="button组件"><a href="#button组件" class="headerlink" title="button组件"></a>button组件</h3><p>&emsp;&emsp;微信小程序中的 button 组件用于创建按钮。</p><ul><li>&lt;bottom&gt;xxxx&lt;&#x2F;bottom&gt;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button <span class="built_in">type</span>=<span class="string">&quot;warn&quot;</span>&gt;我是按钮1&lt;/button&gt;</span><br><span class="line">&lt;button <span class="built_in">type</span>=<span class="string">&quot;primary&quot;</span>&gt;我是按钮2&lt;/button&gt;</span><br><span class="line">&lt;button&gt;我是按钮3&lt;/button&gt;</span><br><span class="line">&lt;button size=<span class="string">&quot;mini&quot;</span>&gt;我是小按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure>显示如下：<br><img src="/images/11.png"></li></ul><h2 id="UI界面设计"><a href="#UI界面设计" class="headerlink" title="UI界面设计"></a>UI界面设计</h2><h3 id="设计软件"><a href="#设计软件" class="headerlink" title="设计软件"></a>设计软件</h3><p>&emsp;&emsp;在小程序开发前端，首先我们需要对脑中灵感进行初步实体化，设计出效果图，后面方便代码模块的实现。<br>&emsp;&emsp;这里推荐一些主流相关设计软件、配色网站以及AI生成图片，快来找寻自己灵感吧。</p><ul><li><a href="https://www.figma.com/downloads/">figma</a>——–UI界面设计软件，<a href="https://www.figma.cool/learning-paths">软件教程</a></li><li><a href="http://colormind.io/">colormind</a>—配色网站</li><li><a href="https://www.craiyon.com/">Craiyon</a>——AI图片生成网址</li><li><a href="https://www.iconfinder.com/">Iconfinder</a>—图标网站</li></ul><p>&emsp;&emsp;为了免费直接使用figma专业版，建议使用学校edu邮箱，并注册教育申请表：<a href="https://www.figma.com/student/apply,%E6%95%99%E8%82%B2%E7%89%88%E5%8F%AF%E5%85%8D%E8%B4%B9%E4%BD%93%E9%AA%8C%E4%B8%A4%E5%B9%B4figma%E4%B8%93%E4%B8%9A%E7%89%88%E3%80%82">https://www.figma.com/student/apply,教育版可免费体验两年figma专业版。</a></p><p>figma常用快捷键：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">空格        拖移面板</span><br><span class="line">ctrl+      放大</span><br><span class="line">ctrl-      缩小</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如下是用figma随机试用后的结果图：<br><img src="/images/20.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo|Next+github博客搭建与自定义域名部署</title>
      <link href="/2024/08/17/blog%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/08/17/blog%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>为什么想建立个人博客?</p><p>&emsp;&emsp;1、知识的沉淀远比新知识的学习更重要。将离散的知识体系做整合，理清思路，归纳总结。  </p><p>&emsp;&emsp;2、记录学习更多计算机，编程方面的知识，方便以后查找。  </p><p>&emsp;&emsp;初识Hexo|Next主题博客，被他界面简洁但功能强大所吸引，非常适合做技术博客。虽然目前主流方式CSDN和简书都能直接发布学习心得，但建立一个自己的博客网站仍是个有趣的事情。本篇博文基于Hexo|Next+Github Pages进行博客搭建，并部署于自定义域名。<span id="more"></span></p><h2 id="本地Hexo安装与配置"><a href="#本地Hexo安装与配置" class="headerlink" title="本地Hexo安装与配置"></a>本地Hexo安装与配置</h2><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>进入<a href="https://git-scm.com/downloads">git官网</a>，找到对应系统环境的安装包并下载。<br>按Ctrl+R调用cmd回车，输入以下代码验证git工具是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h3 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h3><p>进入<a href="https://nodejs.org/en/download/package-manager">Node.js官网</a>，下载对应系统环境的安装包。<br>同样调用cmd检测Node.js是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>显示版本号，说明安装成功，否则，请检查哪一步安装出错。</p><h3 id="github注册与配置"><a href="#github注册与配置" class="headerlink" title="github注册与配置"></a>github注册与配置</h3><p>打开<a href="https://github.com/">github官网</a>,添入自己注册信息，<strong>注意这里用户名最好选用常用的，后面代码库需保持一致。(下文所有yourname都是你注册的用户名)</strong>,已有github账号的小伙伴请直接建立仓库（create a new repository）,这里很重要一点是repository name要写yourname.github.io，然后选择public。<br>下面需要打开gh-pages功能，这样才能进行后续的博客创建。我们点击页面功能区右侧的Settings选项，进入后下来找到Github pages模块，点击Launch Automatic page generator按钮，就会完成gh-pages页面的创建了。过几分钟后，尝试用浏览器访问一下yourname.github.io网址，如果可以正常打开页面，Github部分的工作就完成了。</p><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>首先在你的电脑本地选择一个盘，单独建立一个文件夹目录，方便用来管理后面的博客文件。比如E:&#x2F;Blog，这时候将cmd控制台操作目录cd转换到对应目录下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d E:</span><br><span class="line"><span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure><p><strong>此时控制台的操作目录就变成了你的博客管理目录了</strong>。接着在命令行中分别运行下面的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><p>这里的 -g 选项表示全局安装，使得 Hexo CLI 在系统的任何地方都可以使用。出现notice和warm，不用管。<br>继续输入以下命令测试Hexo安装情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>出现一系列工具版本号，说明安装正常。</p><h3 id="Hexo配置"><a href="#Hexo配置" class="headerlink" title="Hexo配置"></a>Hexo配置</h3><p>对安装后的Hexo进行初始化，建立系列文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init yourname.github.io</span><br><span class="line"><span class="built_in">cd</span> yourname.github.io</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>第一行是新建初始化目录，这一步名字也可以改，但是为了容易区分以及后续的多端管理博客建议可以这么命名。<br>第二行则是将工作目录换到初始化的目录下。<br>第三行是初始化环境，安装所需要的一系列文件。</p><p>完成后，会显示几个重要文件，包括:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">public</span><br><span class="line"><span class="built_in">source</span></span><br><span class="line">themes</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br></pre></td></tr></table></figure><p>到这，Hexo配置基本完成，继续控制台运行如下code：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>第一行是清理生成的静态文件和缓存。它会删除 public 目录下的文件以及 .deploy_git 文件夹中的文件，以确保在重新生成网站时不会有旧文件的残留。<br>第二行生成静态文件。Hexo 会根据你的 Markdown 文件和配置生成网站的静态页面，并将其存放在 public 目录中。<br>第三行是启动本地服务器,在浏览器中预览生成的网站。<br>Hexo主题的结构大体如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">│   ├── default.yml</span><br><span class="line">│   └── zh-Hans.yml</span><br><span class="line">├── layout</span><br><span class="line">│   ├── achieve.swig</span><br><span class="line">│   ├── category.swig</span><br><span class="line">│   ├── index.swig</span><br><span class="line">│   ├── _layout.swig</span><br><span class="line">│   ├── page.swig</span><br><span class="line">│   ├── _partials</span><br><span class="line">│   ├── post.swig</span><br><span class="line">│   └── tag.swig</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── css</span><br><span class="line">    ├── fonts</span><br><span class="line">    ├── img</span><br><span class="line">    ├── js</span><br><span class="line">    └── vendors</span><br></pre></td></tr></table></figure><p>首先有一个_config.yml负责提供主题级别的配置，可以在layout中通过theme.xxx的形式进行调用。 然后languages负责实现博客的i18N功能，如果博客没有多语言的需求，只需要实现一个default.yml即可。 其次是最为重要的layout文件夹，这个里面主要存放博客的结构，Hexo 引擎会使用指定的渲染引擎将layout文件渲染成HTML页面。 最后是source，把所有主题需要用到的资源，比如CSS，Fonts，JS等都存放到这个文件夹中。</p><p>如上code运行后会得到如下关键信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/ .</span><br></pre></td></tr></table></figure><p>这就表明你的博客网站已经在本地开启了服务，这时候你可以尝试用浏览器访问网址<a href="http://localhost:4000，如果能够正常访问你将会看到如下的初始博客页面。">http://localhost:4000，如果能够正常访问你将会看到如下的初始博客页面。</a></p><h2 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h2><h3 id="安装Next"><a href="#安装Next" class="headerlink" title="安装Next"></a>安装Next</h3><p>Hexo可配置的主题特别多，本文选择了一个较为目前主流和简介的主题Next，本人的博客也是基于此主题构建的。感兴趣的可以多参考<a href="https://theme-next.iissnan.com/getting-started.html">Next官方文档</a>。  </p><p>将命令行路径切到你电脑的博客目录下，然后执行下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next.</span><br></pre></td></tr></table></figure><p>如果以上行不通，可尝试手动下载安装主题。<a href="https://github.com/iissnan/hexo-theme-next">访问主题的 GitHub 页面</a>下载ZIP文件（点击 Code 按钮，然后选择 Download ZIP），解压缩文件到你的 Hexo 项目中的 themes&#x2F;next 目录中。</p><p>运行完后运行完成后进入对应的themes目录中即可发现next主题文件夹。这里着重注意两个配置文件，分别是<strong>站点配置文件</strong>和<strong>主题配置文件</strong>，他们的名称都是_config.yml，但是内容和路径都不一样，前者是在博客站点<strong>根目录下面</strong>，后者是在themes&#x2F;next&#x2F;子目录的<strong>主题文件夹</strong>中。</p><h3 id="启动主题"><a href="#启动主题" class="headerlink" title="启动主题"></a>启动主题</h3><p>在完成克隆下载后，打开站点配置文件，找到themes配置字段，设置为对应的主题就可以了，例如这里配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>可以使用hexo发布提交的三条经典命令来测试效果了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开本地的访问连接<a href="http://localhost:4000就可以看到修改后效果了。到此，已完成本地的基本框架的搭建和配置。">http://localhost:4000就可以看到修改后效果了。到此，已完成本地的基本框架的搭建和配置。</a></p><h2 id="Hexo托管至Github"><a href="#Hexo托管至Github" class="headerlink" title="Hexo托管至Github"></a>Hexo托管至Github</h2><h3 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h3><p>由Hexo构建的博客，需要依赖服务器来24小时展示，所以这时候一个强大且可靠的静态网站托管服务就非常有必要了。Github Pages不仅免费且具有简化的部署流程，并且还支持自定义域名，可以轻松将自己的域名与 GitHub Pages 绑定，展示更加专业的博客网站。<br>然而我们必须要锁定对应的主机，并不是任何的电脑都能操作的。这时候就需要身份验证了，而这里使用的就是SSH keys。<br>在<strong>blog控制台的操作目录</strong>下，输入code备份和移除原来的SSH key设置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="comment">#此时会显示一些文件</span></span><br><span class="line"><span class="built_in">mkdir</span> key_backup</span><br><span class="line"><span class="built_in">cp</span> id_rsa* key_backup</span><br><span class="line"><span class="built_in">rm</span> id_rsa* </span><br></pre></td></tr></table></figure><p>生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span> </span><br></pre></td></tr></table></figure><p>此操作在(&#x2F;C&#x2F;Users&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa)生成了密钥id_rsa.pub，利用任意文本编辑器将其打开，复制里面内容，进入 <a href="https://github.com/settings/ssh">github ssh 设置界面</a>将复制的内容粘贴到Key的输入框，Title的内容可以随意，点击Add SSH key按钮即可。验证是否成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>你将会得到如下的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi yourname! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>说明ssh key配置成功。</p><h3 id="配置个人信息"><a href="#配置个人信息" class="headerlink" title="配置个人信息"></a>配置个人信息</h3><p>设置你的账号信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意将上述的yourname和youremail换位自己的用户名和邮箱</strong></p><h3 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h3><p>上文中提到的6个主要文件，我们打开其中的_config.yml，找到Deployment配置的地方，按照如下的内容进行修改，改成你自己的信息，主要是yourname：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>安装部署命令deploy-git ，这样才能用命令部署到GitHub:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git  --save</span><br></pre></td></tr></table></figure><p>本地hexo&#x2F;source中创建一个名为CNAME文件，不要后缀。写上你的域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.jtli.com.cn</span><br></pre></td></tr></table></figure><p>上边修改完毕以后，依次执行以下命令，编译提交本地hexo文件到GitHub:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>hexo d会将生成的静态文件上传到github服务上。</p><h2 id="部署自定义域名"><a href="#部署自定义域名" class="headerlink" title="部署自定义域名"></a>部署自定义域名</h2><p>在万网上购买域名，注册好后进入域名解析设置。</p><p>在<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site">github pages最新的ip地址</a>页面里找到如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To create A records, point your apex domain to the IP addresses <span class="keyword">for</span> GitHub Pages.</span><br></pre></td></tr></table></figure><p>下面的4条ip为github pages的主机地址。<br>我添加时，最新github pages ip更新为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>将4个ip地址全部添加至域名解析的记录值中，其中记录类型选A，主机记录选择@。<br>再将如下ip记录值填入第五个解析中，其中记录类型选择CNAME,主机记录选择www。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yourname.github,io</span><br></pre></td></tr></table></figure><p>添加好后，用阿里云的<a href="https://boce.aliyun.com/detect/http">一级域名检测工具</a>检测你的一级域名（如，jtli.com.cn）的ip是不是刚刚设置4个github pages ip。<br>用测你的二级域名（如<a href="http://www.jtli.com.cn)是不是指向你的github/">www.jtli.com.cn）是不是指向你的github</a> pages地址（如yourname.github.io）</p><p>在GitHub刚创建的仓库里点“Settings” -&gt; “Pages”</p><p>把source改到master，并在custom domain处设置域名并保存，最好不要勾选“Enforce Https”，否则百度爬虫不能抓取网站页面。</p><p>最后打开你的域名，（<a href="http://www.jtli.com.cn),看到hexo页面,表示设置成功./">www.jtli.com.cn），看到Hexo页面，表示设置成功。</a><br>至此，就已完成了博客的整个搭建与部署，现在开始使用吧！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
